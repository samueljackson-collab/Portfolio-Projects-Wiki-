"""
Claude Opus Reviewer
====================
Takes drafts generated by the free AI agent and runs them through
Claude Opus (or better) for quality review and improvement.

This is the final quality gate before entries go live.
The reviewer:
1. Validates technical accuracy
2. Improves prose quality and consistency
3. Ensures style matches existing entries
4. Catches hallucinations or factual errors
5. Polishes code examples
"""

import json
import logging
import os
import re
import time
from typing import Optional

logger = logging.getLogger(__name__)


class OpusReviewer:
    """Reviews and improves AI-generated wiki drafts using Claude Opus."""

    REVIEW_SYSTEM_PROMPT = """You are a senior technical editor reviewing wiki entries for a software engineering portfolio. Your job is to take a draft entry (generated by another AI) and improve it to production quality.

REVIEW CHECKLIST:
1. **Technical Accuracy**: Flag and fix any technologies, patterns, or claims that seem wrong or hallucinated. If you can't verify something, remove it.
2. **Prose Quality**: Tighten descriptions. Remove fluff. Every sentence should add value.
3. **Style Consistency**: Match the tone and structure of the example entries provided.
4. **Code Examples**: Ensure all code is syntactically correct and idiomatic for its language. Fix any issues.
5. **Completeness**: Ensure all required fields are present and substantive.
6. **STRIDE Threat Model**: If present, ensure all 6 categories are covered with specific, actionable mitigations (not generic advice).
7. **ADR Format**: If present, ensure it follows: Status, Context, Decision, Consequences format.
8. **Tags/Technologies**: Ensure proper formatting (tags: lowercase-hyphenated, techs: properly capitalized).

IMPORTANT:
- Return the IMPROVED version of the entry, not a review commentary.
- If the draft is already high quality, return it with minimal changes.
- Do NOT add information you can't verify from the provided context.
- Do NOT change the fundamental structure, only improve content quality.
- Preserve all factual information from the original draft."""

    REVIEW_USER_TEMPLATE = """Review and improve this wiki entry draft.

## Draft Entry
```json
{draft_json}
```

## Change Type
{change_type}

## Original Repository Context
- **Repository:** {repo_name}
- **Description:** {repo_description}
- **Languages:** {languages}

## Existing Wiki Entries (for style reference)
```json
{example_entries}
```

---

Return the improved entry as a JSON object. For change_type "new_repo", return the full Project object. For "new_feature", return the updates object. For "status_update", return the status object. For "new_tech", return the technology deep dive object.

Return ONLY the JSON object, no markdown fences or explanation."""

    def __init__(self, model: str = "claude-opus-4-20250514",
                 temperature: float = 0.2, max_tokens: int = 8192):
        self.model = model
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.api_key = os.environ.get("ANTHROPIC_API_KEY", "")

    def review(self, draft: dict, change_type: str, repo_name: str,
               repo_description: str, languages: str,
               example_entries: list[dict]) -> dict:
        """Review a draft entry and return the improved version."""
        if not self.api_key:
            logger.warning("ANTHROPIC_API_KEY not set. Skipping Opus review.")
            return draft

        user_prompt = self.REVIEW_USER_TEMPLATE.format(
            draft_json=json.dumps(draft, indent=2)[:6000],
            change_type=change_type,
            repo_name=repo_name,
            repo_description=repo_description,
            languages=languages,
            example_entries=json.dumps(example_entries[:2], indent=2)[:4000],
        )

        for attempt in range(3):
            try:
                result = self._call_anthropic(user_prompt)
                reviewed = self._parse_json_response(result)
                logger.info(f"Opus review completed for {repo_name}")
                return reviewed
            except RateLimitError:
                wait = 10 * (attempt + 1)
                logger.warning(f"Anthropic rate limited. Waiting {wait}s...")
                time.sleep(wait)
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Opus response: {e}")
                if attempt < 2:
                    continue
                logger.warning("Returning original draft after review parse failure")
                return draft
            except Exception as e:
                logger.error(f"Opus review error: {e}")
                if attempt < 2:
                    time.sleep(2 ** attempt)
                    continue
                logger.warning("Returning original draft after review failure")
                return draft

        return draft

    def _call_anthropic(self, user_prompt: str) -> str:
        """Call the Anthropic Messages API directly."""
        import urllib.request

        url = "https://api.anthropic.com/v1/messages"
        payload = {
            "model": self.model,
            "max_tokens": self.max_tokens,
            "temperature": self.temperature,
            "system": self.REVIEW_SYSTEM_PROMPT,
            "messages": [
                {"role": "user", "content": user_prompt}
            ],
        }

        data = json.dumps(payload).encode()
        req = urllib.request.Request(
            url, data=data,
            headers={
                "Content-Type": "application/json",
                "x-api-key": self.api_key,
                "anthropic-version": "2023-06-01",
            },
            method="POST"
        )

        try:
            with urllib.request.urlopen(req, timeout=180) as resp:
                result = json.loads(resp.read().decode())
                # Extract text from the response
                content = result.get("content", [])
                for block in content:
                    if block.get("type") == "text":
                        return block["text"]
                raise RuntimeError("No text content in Anthropic response")
        except urllib.error.HTTPError as e:
            if e.code == 429:
                raise RateLimitError("Anthropic rate limit exceeded")
            body = e.read().decode() if e.readable() else str(e)
            raise RuntimeError(f"Anthropic API error {e.code}: {body}")

    def _parse_json_response(self, raw: str) -> dict:
        """Extract and parse JSON from response."""
        raw = raw.strip()
        if raw.startswith("```"):
            raw = re.sub(r'^```\w*\s*\n?', '', raw)
            raw = re.sub(r'\n?```\s*$', '', raw)
        return json.loads(raw)


class RateLimitError(Exception):
    """Raised when an API rate limit is hit."""
    pass
